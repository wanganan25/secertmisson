<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>機密代號：默契考驗</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f5f6fa;
      --surface: #ffffff;
      --ink: #1f2933;
      --accent: #4f46e5;
      --accent-ink: #eef2ff;
      --danger: #ef4444;
      --success: #10b981;
      --neutral: #d4d4d8;
      --card-shadow: 0 10px 28px rgba(15,23,42,.08);
      --radius: 18px;
      --duration: .25s;
      font-family: "Noto Sans TC", "Microsoft JhengHei", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink);
    }

    header {
      background: radial-gradient(circle at top left,#6366f1,#4338ca);
      color: #fff;
      padding: clamp(3rem,5vw,5rem) clamp(1.5rem,6vw,5rem);
      border-bottom-left-radius: 34px;
      border-bottom-right-radius: 34px;
      box-shadow: 0 20px 48px rgba(79,70,229,.35);
    }

    header h1 {
      margin: 0 0 .75rem;
      font-size: clamp(2.5rem,4vw,3.4rem);
      letter-spacing: .06em;
    }

    header p {
      margin: 0;
      max-width: 620px;
      font-size: 1.05rem;
      line-height: 1.7;
    }

    main {
      margin: -55px auto 60px;
      padding: 0 clamp(1.25rem,4vw,3.4rem) 4rem;
      max-width: 1200px;
    }

    .view {
      display: none;
    }

    .view.active {
      display: block;
    }

    .panel {
      background: var(--surface);
      border-radius: var(--radius);
      box-shadow: var(--card-shadow);
      padding: clamp(1.8rem,4vw,2.6rem);
    }

    .lobby-grid {
      display: grid;
      gap: clamp(1.5rem,3vw,2.4rem);
    }

    @media (min-width: 1024px) {
      .lobby-grid { grid-template-columns: 1.1fr 1fr; align-items: start; }
    }

    h2 {
      margin: 0 0 1rem;
      font-size: clamp(1.8rem,3vw,2.2rem);
      display: flex;
      align-items: center;
      gap: .6rem;
    }

    h2 span {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 2.1rem;
      height: 2.1rem;
      border-radius: 50%;
      background: rgba(79,70,229,.15);
      color: #4338ca;
      font-weight: 700;
      font-size: 1rem;
    }

    form {
      display: grid;
      gap: 1rem;
    }

    label {
      font-weight: 600;
      font-size: .95rem;
      display: block;
      margin-bottom: .35rem;
    }

    input, button {
      font: inherit;
    }

    input {
      width: 100%;
      padding: .75rem 1rem;
      border-radius: 12px;
      border: 1px solid #cbd5f5;
      background: #f8fafc;
      transition: border-color var(--duration), box-shadow var(--duration);
    }

    input:focus {
      border-color: #6366f1;
      box-shadow: 0 0 0 3px rgba(99,102,241,.18);
      outline: none;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: .68rem 1.4rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform var(--duration), box-shadow var(--duration), background var(--duration), opacity var(--duration);
      background: linear-gradient(135deg,#6366f1,#4338ca);
      color: #fff;
      box-shadow: 0 14px 32px rgba(67,56,202,.28);
    }

    button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 18px 36px rgba(67,56,202,.32); }
    button:active:not(:disabled) { transform: translateY(0); box-shadow: 0 10px 20px rgba(67,56,202,.25); }
    button:disabled { cursor: not-allowed; opacity: .6; box-shadow: none; }

    .room-list {
      display: grid;
      gap: 1rem;
    }

    .room-card {
      border: 1px solid rgba(99,102,241,.25);
      border-radius: 16px;
      padding: 1.1rem 1.2rem;
      display: grid;
      gap: .6rem;
      background: rgba(99,102,241,.06);
    }

    .room-card h3 {
      margin: 0;
      font-size: 1.25rem;
    }

    .room-meta {
      display: flex;
      flex-wrap: wrap;
      gap: .6rem;
      color: #475569;
      font-size: .92rem;
    }

    .room-status {
      display: inline-flex;
      align-items: center;
      gap: .4rem;
      padding: .3rem .9rem;
      border-radius: 999px;
      font-size: .85rem;
      background: rgba(15,23,42,.08);
      color: #111827;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: .4rem;
      padding: .35rem .8rem;
      border-radius: 999px;
      background: rgba(14,165,233,.12);
      color: #0369a1;
      font-size: .85rem;
    }

    .room-header {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1.5rem;
    }

    .room-header h2 {
      margin: 0;
    }

    .room-header .status-pill {
      background: rgba(15,23,42,.08);
      padding: .45rem 1.1rem;
      border-radius: 999px;
      font-weight: 600;
      font-size: .9rem;
    }

    .room-layout {
      display: grid;
      gap: clamp(1.4rem,2.5vw,2.2rem);
    }

    @media (min-width: 1080px) {
      .room-layout { grid-template-columns: minmax(0,340px) minmax(0,1fr); align-items: start; }
    }

    .player-card {
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,.35);
      padding: .85rem 1rem;
      background: rgba(248,250,252,.7);
      display: grid;
      gap: .3rem;
    }

    .player-card .top-line {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: .6rem;
    }

    .player-card .badge {
      border-radius: 999px;
      padding: .2rem .6rem;
      font-size: .78rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: .35rem;
    }

    .badge.owner { background: rgba(99,102,241,.15); color: #4338ca; }
    .badge.captain { background: rgba(248,113,113,.18); color: #b91c1c; }
    .badge.team-red { background: rgba(239,68,68,.18); color: #b91c1c; }
    .badge.team-blue { background: rgba(59,130,246,.18); color: #1d4ed8; }
    .badge.ready { background: rgba(16,185,129,.2); color: #047857; }
    .badge.waiting { background: rgba(148,163,184,.25); color: #475569; }

    .player-card .name {
      font-size: 1.05rem;
      font-weight: 600;
    }

    .room-actions {
      display: grid;
      gap: .75rem;
      margin-top: 1.2rem;
    }

    .room-actions button { width: 100%; }

    .board-panel {
      display: grid;
      gap: 1.2rem;
    }

    .board-header {
      display: flex;
      flex-wrap: wrap;
      gap: .8rem;
      align-items: center;
      justify-content: space-between;
    }

    .board-header h3 {
      margin: 0;
      font-size: 1.4rem;
    }

    .board-header .right {
      display: flex;
      gap: .6rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(5,minmax(0,1fr));
      gap: .65rem;
    }

    .board.disabled { pointer-events: none; filter: grayscale(.3); opacity: .75; }

    .card {
      position: relative;
      padding: clamp(.68rem,1.5vw,.95rem);
      min-height: 84px;
      border-radius: 14px;
      background: linear-gradient(145deg,#f1f5f9,#e2e8f0);
      color: #1f2933;
      box-shadow: 0 12px 22px rgba(148,163,184,.28);
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-weight: 600;
      text-transform: capitalize;
      cursor: pointer;
      overflow: hidden;
      transition: transform var(--duration), box-shadow var(--duration), filter var(--duration);
    }

    .card:hover { transform: translateY(-2px); box-shadow: 0 16px 28px rgba(100,116,139,.35); }

    .card .label { position: relative; z-index: 1; font-size: clamp(.9rem,1.2vw,1.1rem); line-height: 1.2; }

    .card.revealed {
      color: #f8fafc;
      box-shadow: none;
    }

    .card.revealed::after,
    .board.captain-view .card::after {
      content: "";
      position: absolute;
      inset: 0;
      opacity: .88;
      transition: opacity var(--duration);
    }

    .board.captain-view .card::after { opacity: .3; pointer-events: none; }

    .card.role-red.revealed::after,
    .board.captain-view .card.role-red::after { background: linear-gradient(160deg,#f87171,#ef4444); }
    .card.role-blue.revealed::after,
    .board.captain-view .card.role-blue::after { background: linear-gradient(160deg,#60a5fa,#2563eb); }
    .card.role-neutral.revealed::after,
    .board.captain-view .card.role-neutral::after { background: linear-gradient(160deg,#cbd5f5,#94a3b8); }
    .card.role-assassin.revealed::after,
    .board.captain-view .card.role-assassin::after { background: linear-gradient(160deg,#111827,#0f172a); }

    .scoreboard {
      display: flex;
      flex-wrap: wrap;
      gap: .5rem;
    }

    .score {
      display: inline-flex;
      align-items: center;
      gap: .45rem;
      padding: .35rem .9rem;
      border-radius: 999px;
      font-weight: 600;
      background: rgba(15,23,42,.07);
      color: #0f172a;
      font-size: .9rem;
    }

    .score .dot { width: .7rem; height: .7rem; border-radius: 50%; }

    .winner-banner {
      padding: 1.1rem;
      border-radius: 14px;
      text-align: center;
      font-weight: 700;
      font-size: 1.1rem;
      background: rgba(16,185,129,.15);
      color: #047857;
    }

    .helper-text {
      font-size: .92rem;
      color: #475569;
      margin-top: .4rem;
    }

    .empty-state {
      padding: 1rem 1.2rem;
      border-radius: 12px;
      background: rgba(148,163,184,.18);
      color: #475569;
      line-height: 1.5;
    }

    .danger { background: linear-gradient(135deg,#ef4444,#b91c1c); box-shadow: 0 14px 26px rgba(239,68,68,.32); }
    .ghost {
      background: rgba(148,163,184,.28);
      color: #0f172a;
      box-shadow: none;
    }

    footer {
      text-align: center;
      padding: 2rem 1rem 3rem;
      color: #475569;
    }
  </style>
</head>
<body>
  <header>
    <h1>機密代號：默契考驗</h1>
    <p>建立房間、邀請隊友一起挑戰 5x5 單字密碼。全部成員確認準備後，房主即可開啟回合，系統會自動挑選隊長並分配紅藍兩隊，全員同步追蹤翻牌進度。</p>
  </header>
  <main>
    <section id="lobby-view" class="view active">
      <div class="panel">
        <h2><span>01</span>建立或加入房間</h2>
        <div class="lobby-grid">
          <div>
            <h3 style="margin-top:0;">我要開新房</h3>
            <p class="helper-text">設定房間名稱與最大人數，並留下你的暱稱當房主。</p>
            <form id="create-room-form">
              <div>
                <label for="create-room-name">房間名稱</label>
                <input id="create-room-name" required maxlength="30" placeholder="例如：資管迎新 A 場">
              </div>
              <div>
                <label for="create-room-capacity">最大人數 (2-12)</label>
                <input id="create-room-capacity" type="number" min="2" max="12" value="8" required>
              </div>
              <div>
                <label for="create-room-nickname">你的暱稱</label>
                <input id="create-room-nickname" required maxlength="16" placeholder="輸入暱稱">
              </div>
              <button type="submit">建立房間</button>
            </form>
          </div>
          <div>
            <h3 style="margin-top:0;">加入現有房間</h3>
            <p class="helper-text">選擇列表中的房間並輸入暱稱即可加入。房間滿或已開始遊戲時不能加入。</p>
            <div id="room-list" class="room-list"></div>
          </div>
        </div>
      </div>
    </section>

    <section id="room-view" class="view">
      <div class="panel">
        <div class="room-header">
          <div>
            <button id="leave-room" class="ghost" type="button">← 回房間大廳</button>
          </div>
          <div>
            <h2 id="room-title">房間</h2>
            <div id="room-meta" class="room-meta"></div>
          </div>
          <div class="status-pill" id="room-status">等待中</div>
        </div>
        <div class="room-layout">
          <div>
            <h3 style="margin-top:0;">玩家列表</h3>
            <div id="player-list" class="room-list"></div>
            <div class="room-actions">
              <button id="toggle-ready" type="button">我準備好了</button>
              <button id="start-game" type="button" disabled>開始遊戲</button>
              <button id="reset-game" type="button" class="ghost" disabled>重新回到準備狀態</button>
            </div>
          </div>
          <div class="board-panel">
            <div class="board-header">
              <div>
                <h3>任務地圖</h3>
                <div id="board-score" class="scoreboard"></div>
              </div>
              <div class="right">
                <div id="view-indicator" class="pill">尚未開始</div>
              </div>
            </div>
            <div id="board-grid" class="board"></div>
            <div id="winner-banner" class="winner-banner" style="display:none;"></div>
          </div>
        </div>
      </div>
    </section>
  </main>
  <footer>
    單頁模擬多人流程，適合活動主持人示範或規劃迎新流程使用。
  </footer>
  <script>
    const wordPool = [
      "adventure","analysis","balance","beacon","bridge","canvas","celebration","challenge","clarity","compass","confidence","connection","courage","creative","dawn","discovery","dream","energy","focus","friend","future","galaxy","harmony","idea","insight","journey","knowledge","legend","light","logic","memory","mission","momentum","mystery","network","ocean","origin","pioneer","puzzle","quest","rhythm","rocket","science","signal","spirit","story","strategy","sunrise","teamwork","victory","vision","voice","whisper","wisdom","wonder","勇氣","陪伴","舞台","突破","信任","導航","熱血","制服","課本","筆記","系辦","宿舍","迎新","笑聲","夥伴","挑戰","咖啡","創意","默契","藍圖","熱舞","報到","掌聲","合照","社團","系學會","冒險","新生","學長","學姐","教室","操場","期初","夜唱","旅行","海邊","燈塔","星空","火花","羅盤","影子","記憶","步伐","弧光","勇者","信號","驚喜","高歌","電光","火箭","能量","節奏"
    ];

    const state = {
      rooms: [],
      currentRoomId: null,
      currentPlayerId: null
    };

    const STORAGE_KEY = 'codenameRooms-v1';

    function loadRoomsFromStorage() {
      if (!('localStorage' in window)) return [];
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        return parsed.map(room => ({
          ...room,
          players: Array.isArray(room.players) ? room.players.map(player => ({ ...player })) : [],
          state: room.state ? {
            ...room.state,
            cards: Array.isArray(room.state.cards) ? room.state.cards.map(card => ({ ...card })) : []
          } : { cards: [], winner: null, startingTeam: 'red' }
        }));
      } catch (error) {
        console.warn('讀取房間資料失敗', error);
        return [];
      }
    }

    function saveRoomsToStorage() {
      if (!('localStorage' in window)) return;
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state.rooms));
      } catch (error) {
        console.warn('無法儲存房間資料', error);
      }
    }

    const lobbyView = document.getElementById('lobby-view');
    const roomView = document.getElementById('room-view');
    const roomListEl = document.getElementById('room-list');
    const playerListEl = document.getElementById('player-list');
    const roomTitleEl = document.getElementById('room-title');
    const roomMetaEl = document.getElementById('room-meta');
    const roomStatusEl = document.getElementById('room-status');
    const viewIndicatorEl = document.getElementById('view-indicator');
    const boardGridEl = document.getElementById('board-grid');
    const boardScoreEl = document.getElementById('board-score');
    const winnerBannerEl = document.getElementById('winner-banner');
    const toggleReadyBtn = document.getElementById('toggle-ready');
    const startGameBtn = document.getElementById('start-game');
    const resetGameBtn = document.getElementById('reset-game');

    function uuid() {
      if (window.crypto && crypto.randomUUID) return crypto.randomUUID();
      return 'id-' + Math.random().toString(36).slice(2, 11);
    }

    function shuffle(arr) {
      const copy = [...arr];
      for (let i = copy.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy;
    }

    function getCurrentRoom() {
      return state.rooms.find(r => r.id === state.currentRoomId) ?? null;
    }

    function getCurrentPlayer(room = getCurrentRoom()) {
      if (!room) return null;
      return room.players.find(p => p.id === state.currentPlayerId) ?? null;
    }

    function updateViews() {
      const inRoom = Boolean(getCurrentRoom());
      lobbyView.classList.toggle('active', !inRoom);
      roomView.classList.toggle('active', inRoom);
      renderRoomList();
      if (inRoom) {
        renderRoomDetail();
      }
    }

    function renderRoomList() {
      if (!state.rooms.length) {
        roomListEl.innerHTML = '<div class="empty-state">目前沒有房間，歡迎成為第一位房主！</div>';
        return;
      }
      roomListEl.innerHTML = state.rooms.map(room => {
        const occupied = room.players.length;
        const isFull = occupied >= room.capacity;
        const status = room.status === 'lobby' ? '等待開始' : room.status === 'in-progress' ? '遊戲進行中' : '已結束';
        const disabled = isFull || room.status === 'in-progress';
        return `<div class="room-card">
          <div style="display:flex;justify-content:space-between;gap:.6rem;align-items:flex-start;">
            <h3>${room.name}</h3>
            <span class="room-status">${status}</span>
          </div>
          <div class="room-meta">
            <span>房主：${room.ownerName}</span>
            <span>人數：${occupied}/${room.capacity}</span>
          </div>
          <button data-room="${room.id}" class="join-room" ${disabled ? 'disabled' : ''}>加入房間</button>
        </div>`;
      }).join('');
    }

    function renderRoomDetail() {
      const room = getCurrentRoom();
      const player = getCurrentPlayer(room);
      if (!room || !player) {
        state.currentRoomId = null;
        state.currentPlayerId = null;
        updateViews();
        return;
      }
      roomTitleEl.textContent = room.name;
      roomMetaEl.textContent = `房主：${room.ownerName}｜玩家 ${room.players.length}/${room.capacity}`;
      const statusText = room.status === 'lobby' ? '等待準備中' : room.status === 'in-progress' ? '遊戲進行中' : '本局結束';
      roomStatusEl.textContent = statusText;

      playerListEl.innerHTML = room.players.map(p => {
        const badges = [];
        if (p.id === room.ownerId) badges.push('<span class="badge owner">房主</span>');
        if (p.team) badges.push(`<span class="badge team-${p.team}">${p.team === 'red' ? '紅隊' : '藍隊'}</span>`);
        if (p.isCaptain) badges.push('<span class="badge captain">隊長</span>');
        badges.push(`<span class="badge ${p.ready ? 'ready' : 'waiting'}">${p.ready ? '已準備' : '等待中'}</span>`);
        return `<div class="player-card">
          <div class="top-line">
            <span class="name">${p.name}</span>
          </div>
          <div style="display:flex;flex-wrap:wrap;gap:.4rem;">${badges.join('')}</div>
        </div>`;
      }).join('');

      const readyLabel = player.ready ? '取消準備' : '我準備好了';
      toggleReadyBtn.textContent = readyLabel;
      toggleReadyBtn.disabled = room.status !== 'lobby';

      const everyoneReady = room.players.length >= 2 && room.players.every(p => p.ready);
      const isOwner = player.id === room.ownerId;
      startGameBtn.disabled = !(room.status === 'lobby' && isOwner && everyoneReady);

      resetGameBtn.disabled = !(isOwner && room.status !== 'lobby');

      if (room.status === 'in-progress') {
        const viewText = player.isCaptain ? '你是隊長，可查看全部顏色' : `你是${player.team === 'red' ? '紅隊' : '藍隊'}成員，只能看到已翻開的卡片`;
        viewIndicatorEl.textContent = viewText;
      } else if (room.status === 'finished') {
        viewIndicatorEl.textContent = '本局結束，等待房主重設';
      } else {
        viewIndicatorEl.textContent = '尚未開始';
      }

      renderBoard(room, player);
    }

    function generateBoard(startingTeam = 'red') {
      const otherTeam = startingTeam === 'red' ? 'blue' : 'red';
      const boardWords = shuffle(wordPool).slice(0, 25);
      const roles = [
        ...Array(9).fill(startingTeam),
        ...Array(8).fill(otherTeam),
        ...Array(7).fill('neutral'),
        'assassin'
      ];
      const shuffledRoles = shuffle(roles);
      return boardWords.map((word, idx) => ({
        word,
        role: shuffledRoles[idx],
        revealed: false
      }));
    }

    function renderBoard(room, player) {
      if (!room.state) room.state = {};
      if (!room.state.cards || !room.state.cards.length) {
        boardGridEl.innerHTML = '<div class="empty-state">等待房主開始遊戲後才會生成任務地圖。</div>';
        boardGridEl.classList.remove('captain-view');
        boardGridEl.classList.add('disabled');
        boardScoreEl.innerHTML = '';
        winnerBannerEl.style.display = 'none';
        return;
      }
      boardGridEl.classList.toggle('captain-view', Boolean(player && player.isCaptain));
      boardGridEl.classList.toggle('disabled', room.status !== 'in-progress');
      boardGridEl.innerHTML = room.state.cards.map((card, idx) => {
        const revealedClass = card.revealed ? ' revealed' : '';
        const roleClass = ` role-${card.role}`;
        return `<div class="card${roleClass}${revealedClass}" data-index="${idx}"><span class="label">${card.word}</span></div>`;
      }).join('');
      updateScoreboard(room);
      if (room.state.winner) {
        const winnerName = room.state.winner === 'red' ? '紅隊勝利！' : '藍隊勝利！';
        winnerBannerEl.textContent = winnerName;
        winnerBannerEl.style.display = 'block';
      } else {
        winnerBannerEl.style.display = 'none';
      }
    }

    function updateScoreboard(room) {
      if (!room.state || !room.state.cards) {
        boardScoreEl.innerHTML = '';
        return;
      }
      const counts = { red: 0, blue: 0, neutral: 0, assassin: 0 };
      room.state.cards.forEach(card => {
        if (!card.revealed) counts[card.role] = (counts[card.role] || 0) + 1;
      });
      boardScoreEl.innerHTML = `
        <span class="score"><span class="dot" style="background:#ef4444"></span>紅隊剩 ${counts.red}</span>
        <span class="score"><span class="dot" style="background:#2563eb"></span>藍隊剩 ${counts.blue}</span>
        <span class="score"><span class="dot" style="background:#94a3b8"></span>中立 ${counts.neutral}</span>
        <span class="score"><span class="dot" style="background:#0f172a"></span>刺客 ${counts.assassin}</span>
      `;
    }

    function ensureRoomState(room) {
      if (!room.state) {
        room.state = {
          cards: [],
          winner: null,
          startingTeam: 'red'
        };
      }
      if (!room.state.cards) room.state.cards = [];
    }

    function assignTeamsAndBoard(room) {
      ensureRoomState(room);
      const shuffledPlayers = shuffle(room.players);
      const midpoint = Math.ceil(shuffledPlayers.length / 2);
      shuffledPlayers.forEach((player, idx) => {
        player.team = idx < midpoint ? 'red' : 'blue';
        player.isCaptain = false;
      });
      const captain = shuffledPlayers[Math.floor(Math.random() * shuffledPlayers.length)];
      if (captain) captain.isCaptain = true;
      const startingTeam = Math.random() < 0.5 ? 'red' : 'blue';
      room.state.startingTeam = startingTeam;
      room.state.cards = generateBoard(startingTeam);
      room.state.winner = null;
    }

    function checkVictory(room, triggeringPlayer, card) {
      const remaining = {
        red: room.state.cards.filter(c => c.role === 'red' && !c.revealed).length,
        blue: room.state.cards.filter(c => c.role === 'blue' && !c.revealed).length
      };
      if (card.role === 'assassin') {
        room.state.winner = triggeringPlayer.team === 'red' ? 'blue' : 'red';
      } else if (remaining.red === 0) {
        room.state.winner = 'red';
      } else if (remaining.blue === 0) {
        room.state.winner = 'blue';
      }
      if (room.state.winner) {
        room.status = 'finished';
      }
    }

    function removePlayerFromRoom(room, playerId) {
      if (!room) return;
      const idx = room.players.findIndex(p => p.id === playerId);
      if (idx >= 0) room.players.splice(idx, 1);
      if (room.ownerId === playerId) {
        room.ownerId = room.players[0]?.id ?? null;
        room.ownerName = room.players[0]?.name ?? room.ownerName;
      }
      if (!room.players.length) {
        state.rooms = state.rooms.filter(r => r.id !== room.id);
      }
    }

    document.getElementById('create-room-form').addEventListener('submit', event => {
      event.preventDefault();
      const name = document.getElementById('create-room-name').value.trim();
      const capacity = Number(document.getElementById('create-room-capacity').value);
      const nickname = document.getElementById('create-room-nickname').value.trim();
      if (!name || !nickname) return;
      if (capacity < 2 || capacity > 12) return;
      const roomId = uuid();
      const playerId = uuid();
      const player = {
        id: playerId,
        name: nickname,
        ready: false,
        team: null,
        isCaptain: false
      };
      const room = {
        id: roomId,
        name,
        capacity,
        ownerId: playerId,
        ownerName: nickname,
        status: 'lobby',
        players: [player],
        state: {
          cards: [],
          winner: null,
          startingTeam: 'red'
        }
      };
      state.rooms.push(room);
      state.currentRoomId = roomId;
      state.currentPlayerId = playerId;
      saveRoomsToStorage();
      updateViews();
      event.target.reset();
    });

    roomListEl.addEventListener('click', event => {
      const target = event.target.closest('.join-room');
      if (!target) return;
      const roomId = target.dataset.room;
      const room = state.rooms.find(r => r.id === roomId);
      if (!room || room.players.length >= room.capacity || room.status !== 'lobby') return;
      const nickname = prompt('輸入你的暱稱');
      if (!nickname) return;
      const trimmed = nickname.trim();
      if (!trimmed) return;
      const playerId = uuid();
      room.players.push({
        id: playerId,
        name: trimmed.slice(0, 16),
        ready: false,
        team: null,
        isCaptain: false
      });
      state.currentRoomId = roomId;
      state.currentPlayerId = playerId;
      saveRoomsToStorage();
      updateViews();
    });

    toggleReadyBtn.addEventListener('click', () => {
      const room = getCurrentRoom();
      const player = getCurrentPlayer(room);
      if (!room || !player || room.status !== 'lobby') return;
      player.ready = !player.ready;
      saveRoomsToStorage();
      updateViews();
    });

    startGameBtn.addEventListener('click', () => {
      const room = getCurrentRoom();
      const player = getCurrentPlayer(room);
      if (!room || !player || player.id !== room.ownerId) return;
      const everyoneReady = room.players.length >= 2 && room.players.every(p => p.ready);
      if (!everyoneReady) return;
      assignTeamsAndBoard(room);
      room.status = 'in-progress';
      saveRoomsToStorage();
      updateViews();
    });

    resetGameBtn.addEventListener('click', () => {
      const room = getCurrentRoom();
      const player = getCurrentPlayer(room);
      if (!room || !player || player.id !== room.ownerId) return;
      room.status = 'lobby';
      room.players.forEach(p => {
        p.ready = false;
        p.team = null;
        p.isCaptain = false;
      });
      room.state.cards = [];
      room.state.winner = null;
      saveRoomsToStorage();
      updateViews();
    });

    boardGridEl.addEventListener('click', event => {
      const cardEl = event.target.closest('.card');
      if (!cardEl) return;
      const room = getCurrentRoom();
      const player = getCurrentPlayer(room);
      if (!room || !player || room.status !== 'in-progress') return;
      const index = Number(cardEl.dataset.index);
      const card = room.state.cards[index];
      if (!card || card.revealed) return;
      card.revealed = true;
      checkVictory(room, player, card);
      saveRoomsToStorage();
      updateViews();
    });

    document.getElementById('leave-room').addEventListener('click', () => {
      const room = getCurrentRoom();
      const player = getCurrentPlayer(room);
      if (!room || !player) return;
      removePlayerFromRoom(room, player.id);
      state.currentRoomId = null;
      state.currentPlayerId = null;
      saveRoomsToStorage();
      updateViews();
    });

    window.addEventListener('storage', event => {
      if (event.key !== STORAGE_KEY) return;
      state.rooms = loadRoomsFromStorage();
      const room = getCurrentRoom();
      const player = getCurrentPlayer(room);
      if (!room || !player) {
        state.currentRoomId = null;
        state.currentPlayerId = null;
      }
      updateViews();
    });

    state.rooms = loadRoomsFromStorage();
    updateViews();
  </script>
</body>
</html>
