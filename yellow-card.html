<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>瘋狂黃牌大挑戰｜房間大廳</title>
  <style>
    :root {
      color-scheme: light;
      font-family: "Noto Sans TC", "Microsoft JhengHei", system-ui, sans-serif;
      --bg-top: #fff4cc;
      --bg-bottom: #ffc15e;
      --panel: rgba(255, 255, 255, 0.96);
      --accent: #ef476f;
      --accent-dark: #d9365d;
      --ink: #17212b;
      --ink-soft: #44515f;
      --divider: rgba(17, 24, 39, 0.12);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      padding: clamp(1.5rem, 5vw, 4rem);
      background: linear-gradient(155deg, var(--bg-top) 0%, var(--bg-bottom) 48%, #ef476f 100%);
      color: var(--ink);
    }
    main {
      width: min(1200px, 100%);
      background: var(--panel);
      border-radius: 30px;
      box-shadow: 0 32px 78px rgba(23, 33, 43, 0.24);
      padding: clamp(2.2rem, 5vw, 3.4rem);
      display: grid;
      gap: clamp(2rem, 4vw, 3rem);
    }
    header h1 {
      margin: 0 0 .6rem;
      font-size: clamp(2.2rem, 5vw, 3.2rem);
      letter-spacing: .08em;
    }
    header p {
      margin: 0;
      line-height: 1.7;
      color: var(--ink-soft);
      max-width: 70ch;
    }
    section {
      background: rgba(255, 255, 255, 0.94);
      border: 1px solid rgba(255, 209, 102, 0.55);
      border-radius: 26px;
      padding: clamp(1.4rem, 3.6vw, 2.4rem);
      display: grid;
      gap: 1.2rem;
    }
    section h2 {
      margin: 0;
      font-size: clamp(1.3rem, 3vw, 1.8rem);
      display: flex;
      align-items: center;
      gap: .8rem;
    }
    section h2 span {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 2.5rem;
      height: 2.5rem;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent), var(--accent-dark));
      color: #fff;
      font-size: 1rem;
      font-weight: 700;
      letter-spacing: .08em;
    }
    .subtext {
      font-size: .95rem;
      color: var(--ink-soft);
      margin: 0;
    }
    input, select, button {
      font: inherit;
    }
    input, select {
      width: 100%;
      padding: .7rem 1rem;
      border-radius: 16px;
      border: 1px solid rgba(17, 24, 39, 0.18);
      background: rgba(255, 255, 255, 0.98);
    }
    button {
      border: none;
      border-radius: 999px;
      padding: .7rem 1.5rem;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: .4rem;
      transition: transform .16s ease, box-shadow .16s ease, opacity .16s ease;
    }
    button:hover:not([disabled]) { transform: translateY(-2px); }
    button:active:not([disabled]) { transform: translateY(1px); }
    button[disabled] { opacity: .55; cursor: not-allowed; transform: none; box-shadow: none; }
    .btn-primary {
      background: linear-gradient(135deg, var(--accent), var(--accent-dark));
      color: #fff;
      box-shadow: 0 16px 30px rgba(239, 71, 111, 0.32);
    }
    .btn-ghost {
      background: rgba(17, 24, 39, 0.08);
      color: var(--ink);
      box-shadow: none;
    }
    .room-grid {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }
    .room-card {
      border-radius: 22px;
      border: 1px solid rgba(239, 71, 111, 0.2);
      padding: 1.1rem 1.3rem;
      display: grid;
      gap: .8rem;
      background: rgba(255, 255, 255, 0.96);
      box-shadow: 0 16px 36px rgba(239, 71, 111, 0.2);
      transition: transform .18s ease, box-shadow .18s ease;
    }
    .room-card.active {
      transform: translateY(-4px);
      box-shadow: 0 22px 48px rgba(239, 71, 111, 0.3);
      border-color: rgba(239, 71, 111, 0.45);
    }
    .room-name { font-size: 1.25rem; font-weight: 700; }
    .room-meta {
      display: flex;
      flex-direction: column;
      gap: .3rem;
      font-size: .95rem;
      color: var(--ink-soft);
    }
    .badges {
      display: flex;
      flex-wrap: wrap;
      gap: .45rem;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      padding: .28rem .7rem;
      border-radius: 999px;
      font-size: .8rem;
      letter-spacing: .05em;
      background: rgba(17, 24, 39, 0.08);
      color: var(--ink);
    }
    .badge.host { background: rgba(239, 71, 111, 0.18); color: var(--accent-dark); }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: .95rem;
    }
    th, td {
      padding: .65rem .8rem;
      border-bottom: 1px solid var(--divider);
      text-align: left;
    }
    tbody tr.host { background: rgba(239, 71, 111, 0.12); }
    tbody tr.me { background: rgba(56, 189, 248, 0.18); }
    .pill {
      display: inline-flex;
      align-items: center;
      padding: .28rem .8rem;
      border-radius: 999px;
      background: rgba(17, 24, 39, 0.08);
      font-size: .78rem;
      letter-spacing: .04em;
    }
    .hidden { display: none !important; }
    footer {
      text-align: center;
      font-size: .92rem;
      color: rgba(17, 24, 39, 0.65);
    }
    footer a { color: var(--accent-dark); font-weight: 600; text-decoration: none; }
    @media (max-width: 720px) {
      body { padding: 1.2rem; }
      main { padding: 1.6rem; }
      section { padding: 1.2rem; }
      th, td { font-size: .88rem; }
    }
  </style>
</head>
<body>
  <main>
    <header>
      <h1>瘋狂黃牌大挑戰｜同步房間大廳</h1>
      <p>直接連線到 Firestore 的 yellowRooms 集合即可顯示所有房間。輸入暱稱後加入房間，第一位玩家會成為房主，負責開局、抽題目與管理玩家。</p>
    </header>

    <section id="room-section">
      <h2><span>01</span>選擇房間與暱稱</h2>
      <p class="subtext">請先輸入暱稱，再從下方房間列表選擇加入。若房間已滿或有重複暱稱，系統會立即提示。</p>
      <div style="display:grid;gap:1rem;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));align-items:end;">
        <label>我的暱稱
          <input id="nickname" placeholder="輸入暱稱">
        </label>
        <div id="current-room-box" class="hidden" style="display:grid;gap:.6rem;">
          <div>
            <strong id="current-room-name">目前房間：—</strong>
            <p id="current-room-info" class="subtext" style="margin:.25rem 0 0;">尚未加入房間</p>
          </div>
          <div style="display:flex;flex-wrap:wrap;gap:.55rem;">
            <button id="btn-ready" class="btn-ghost">我準備好了</button>
            <button id="btn-leave" class="btn-ghost">離開房間</button>
            <button id="btn-start" class="btn-ghost hidden">房主開始新回合</button>
          </div>
        </div>
      </div>
      <div id="room-cards" class="room-grid"></div>
    </section>

    <section id="status-panel" class="hidden">
      <h2><span>02</span>房間狀態</h2>
      <p id="game-phase" class="subtext">遊戲狀態：等待加入</p>
      <p id="judge-info" class="subtext">本局裁判：—</p>
      <div class="room-card" style="background:rgba(239,244,255,.55);">
        <h3 style="margin:0 0 .4rem;">目前題目</h3>
        <p id="topic-text" style="margin:0;line-height:1.6;">尚未抽題目</p>
        <span id="topic-remaining" class="pill">剩餘題目：--</span>
      </div>
    </section>

    <section id="players-panel" class="hidden">
      <h2><span>03</span>玩家列表與操作</h2>
      <div style="overflow-x:auto;">
        <table>
          <thead>
            <tr>
              <th>玩家</th>
              <th>身分</th>
              <th>黃牌</th>
              <th>準備</th>
              <th>手牌</th>
              <th>操作</th>
            </tr>
          </thead>
          <tbody id="players-body"></tbody>
        </table>
      </div>
    </section>

    <section id="host-panel" class="hidden">
      <h2><span>04</span>房主 / 裁判工具</h2>
      <div style="display:flex;flex-wrap:wrap;gap:.6rem;">
        <button id="btn-draw-topic" class="btn-primary">抽題目卡</button>
        <button id="btn-recycle-topic" class="btn-ghost">題庫回收並洗牌</button>
        <button id="btn-reset-room" class="btn-ghost">重設房間</button>
      </div>
      <div style="display:grid;gap:.8rem;">
        <h3 style="margin:0;">匿名提交</h3>
        <div id="submission-list" style="display:grid;gap:.6rem;"></div>
      </div>
    </section>

    <section id="player-panel" class="hidden">
      <h2><span>05</span>提交我的詞語</h2>
      <form id="submit-form" style="display:grid;gap:.8rem;max-width:520px;">
        <label class="subtext" for="hand-select">從手牌中選擇要填入題目的詞語</label>
        <select id="hand-select"></select>
        <button type="submit" class="btn-primary">確認送出</button>
      </form>
    </section>

    <footer>
      <p>任何玩家累積 3 張黃牌即宣布結束，黃牌最少者獲勝。完成活動後可返回 <a href="index.html">主頁</a>。</p>
    </footer>
  </main>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-auth.js";
    import {
      getFirestore,
      collection,
      doc,
      getDocs,
      onSnapshot,
      runTransaction,
      updateDoc,
      deleteDoc,
      serverTimestamp,
      query,
      orderBy
    } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyADGfYlLyMB-W5A2JM6uF8VqTiF3LL9lEI",
      authDomain: "secertmisson-19e11.firebaseapp.com",
      databaseURL: "https://secertmisson-19e11-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "secertmisson-19e11",
      storageBucket: "secertmisson-19e11.firebasestorage.app",
      messagingSenderId: "730645471093",
      appId: "1:730645471093:web:dacceb7a79256deb06fd3c"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    const state = {
      clientId: localStorage.getItem("yellowcard-client-id") || crypto.randomUUID(),
      nickname: "",
      roomsUnsub: null,
      roomDocUnsub: null,
      playersUnsub: null,
      submissionsUnsub: null,
      currentRoomId: null,
      currentRoomData: null,
      playerMap: new Map()
    };
    localStorage.setItem("yellowcard-client-id", state.clientId);

    const nicknameInput = document.getElementById("nickname");
    const roomCardsEl = document.getElementById("room-cards");
    const currentRoomBox = document.getElementById("current-room-box");
    const currentRoomName = document.getElementById("current-room-name");
    const currentRoomInfo = document.getElementById("current-room-info");
    const btnReady = document.getElementById("btn-ready");
    const btnLeave = document.getElementById("btn-leave");
    const btnStart = document.getElementById("btn-start");
    const btnDrawTopic = document.getElementById("btn-draw-topic");
    const btnRecycleTopic = document.getElementById("btn-recycle-topic");
    const btnResetRoom = document.getElementById("btn-reset-room");
    const statusPanel = document.getElementById("status-panel");
    const playersPanel = document.getElementById("players-panel");
    const hostPanel = document.getElementById("host-panel");
    const playerPanel = document.getElementById("player-panel");
    const gamePhaseEl = document.getElementById("game-phase");
    const judgeInfoEl = document.getElementById("judge-info");
    const topicTextEl = document.getElementById("topic-text");
    const topicRemainingEl = document.getElementById("topic-remaining");
    const playersBody = document.getElementById("players-body");
    const submissionList = document.getElementById("submission-list");
    const submitForm = document.getElementById("submit-form");
    const handSelect = document.getElementById("hand-select");

    nicknameInput.addEventListener("input", () => {
      state.nickname = nicknameInput.value.trim();
    });

    btnReady.addEventListener("click", () => {
      if (state.currentRoomId) toggleReady();
    });

    btnLeave.addEventListener("click", () => {
      if (state.currentRoomId) leaveRoom(state.currentRoomId);
    });

    btnStart.addEventListener("click", () => {
      if (state.currentRoomId) startRound();
    });

    btnDrawTopic.addEventListener("click", drawTopic);
    btnRecycleTopic.addEventListener("click", recycleTopics);
    btnResetRoom.addEventListener("click", resetRoom);

    submitForm.addEventListener("submit", (event) => {
      event.preventDefault();
      if (!state.currentRoomId) return;
      const word = handSelect.value;
      if (!word) {
        alert("目前沒有可提交的詞語");
        return;
      }
      submitHand(word);
    });

    signInAnonymously(auth).catch(console.error);
    onAuthStateChanged(auth, (user) => {
      if (user && !state.roomsUnsub) subscribeRooms();
    });

    function subscribeRooms() {
      const roomsRef = collection(db, "yellowRooms");
      state.roomsUnsub = onSnapshot(roomsRef, (snapshot) => {
        const rooms = snapshot.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }));
        renderRoomCards(rooms);
      });
    }

    function renderRoomCards(rooms) {
      roomCardsEl.innerHTML = "";
      rooms.forEach((room) => {
        const card = document.createElement("article");
        card.className = "room-card" + (room.id === state.currentRoomId ? " active" : "");
        const playerCount = Array.isArray(room.playerIds) ? room.playerIds.length : (room.playerCount || 0);
        const capacity = room.capacity || 8;
        card.innerHTML = `
          <div>
            <div class="room-name">${room.name || room.id}</div>
            <div class="room-meta">
              <span>玩家：${playerCount} / ${capacity}</span>
              <span>題目剩餘：${Array.isArray(room.topicDeck) ? room.topicDeck.length : 0}</span>
            </div>
          </div>
          <div class="badges"></div>
          <div style="display:flex;gap:.5rem;flex-wrap:wrap;">
            <button class="btn-primary" data-action="join">加入房間</button>
            <button class="btn-ghost" data-action="peek">僅檢視</button>
          </div>
        `;
        const badges = card.querySelector(".badges");
        if (room.hostId) {
          badges.appendChild(makeBadge(`房主 ${room.hostNickname || "—"}`, "host"));
        }
        if (room.currentTopic) {
          badges.appendChild(makeBadge("進行中", ""));
        }
        card.querySelector('[data-action="join"]').addEventListener("click", () => joinRoom(room.id));
        card.querySelector('[data-action="peek"]').addEventListener("click", () => watchRoom(room.id, true));
        roomCardsEl.appendChild(card);
      });
    }

    function makeBadge(text, extra) {
      const span = document.createElement("span");
      span.className = "badge" + (extra ? ` ${extra}` : "");
      span.textContent = text;
      return span;
    }

    async function joinRoom(roomId) {
      const nickname = (state.nickname || nicknameInput.value || "").trim();
      if (!nickname) {
        alert("請先輸入暱稱");
        nicknameInput.focus();
        return;
      }
      try {
        await runTransaction(db, async (tx) => {
          const roomRef = doc(db, "yellowRooms", roomId);
          const roomSnap = await tx.get(roomRef);
          if (!roomSnap.exists()) throw new Error("房間不存在");
          const data = roomSnap.data();
          const capacity = data.capacity || 8;
          const playerIds = Array.isArray(data.playerIds) ? [...data.playerIds] : [];
          const already = playerIds.includes(state.clientId);
          const playersRef = collection(roomRef, "players");
          const meRef = doc(playersRef, state.clientId);
          const meSnap = await tx.get(meRef);
          if (!already) {
            if (playerIds.length >= capacity) throw new Error("房間已滿");
            const sameName = await getDocs(playersRef);
            sameName.forEach((docSnap) => {
              if (docSnap.data().nickname === nickname) {
                throw new Error("房間內已有相同暱稱");
              }
            });
            playerIds.push(state.clientId);
            const isHost = !data.hostId;
            const wordDeck = Array.isArray(data.wordDeck) ? [...data.wordDeck] : [];
            const drawCount = Math.min(13, wordDeck.length);
            const hand = wordDeck.splice(0, drawCount);
            tx.update(roomRef, {
              playerIds,
              playerCount: playerIds.length,
              hostId: isHost ? state.clientId : (data.hostId || null),
              hostNickname: isHost ? nickname : (data.hostNickname || null),
              wordDeck,
              updatedAt: serverTimestamp()
            });
            tx.set(meRef, {
              nickname,
              hand,
              yellowCards: 0,
              ready: false,
              isHost,
              joinedAt: serverTimestamp(),
              lastActive: serverTimestamp()
            });
          } else {
            tx.update(meRef, {
              nickname,
              lastActive: serverTimestamp()
            });
          }
        });
        state.nickname = nickname;
        nicknameInput.value = nickname;
        await watchRoom(roomId, false);
      } catch (error) {
        console.error(error);
        alert(error.message || "加入房間失敗");
      }
    }

    async function leaveRoom(roomId) {
      cleanupRoomWatch();
      try {
        await runTransaction(db, async (tx) => {
          const roomRef = doc(db, "yellowRooms", roomId);
          const roomSnap = await tx.get(roomRef);
          if (!roomSnap.exists()) return;
          const data = roomSnap.data();
          const playerIds = Array.isArray(data.playerIds) ? [...data.playerIds] : [];
          const index = playerIds.indexOf(state.clientId);
          if (index === -1) return;
          playerIds.splice(index, 1);
          const playersRef = collection(roomRef, "players");
          const meRef = doc(playersRef, state.clientId);
          const meSnap = await tx.get(meRef);
          const meData = meSnap.exists() ? meSnap.data() : null;
          tx.delete(meRef);
          let hostId = data.hostId || null;
          let hostNickname = data.hostNickname || null;
          if (hostId === state.clientId) {
            hostId = playerIds[0] || null;
            if (hostId) {
              const newHostRef = doc(playersRef, hostId);
              const newHostSnap = await tx.get(newHostRef);
              if (newHostSnap.exists()) {
                const newHost = newHostSnap.data();
                hostNickname = newHost.nickname || null;
                tx.update(newHostRef, { isHost: true });
              }
            } else {
              hostNickname = null;
            }
          }
          tx.update(roomRef, {
            playerIds,
            playerCount: playerIds.length,
            hostId,
            hostNickname,
            updatedAt: serverTimestamp()
          });
          if (meData && Array.isArray(meData.hand) && meData.hand.length) {
            const deck = Array.isArray(data.wordDeck) ? [...data.wordDeck] : [];
            tx.update(roomRef, { wordDeck: [...deck, ...meData.hand] });
          }
        });
      } catch (error) {
        console.error(error);
        alert(error.message || "離開房間失敗");
      }
      updateRoomUI(null, null);
    }

    async function toggleReady() {
      const roomId = state.currentRoomId;
      if (!roomId) return;
      const player = state.playerMap.get(state.clientId);
      if (!player) return;
      await updateDoc(doc(db, "yellowRooms", roomId, "players", state.clientId), {
        ready: !player.ready,
        lastActive: serverTimestamp()
      });
    }

    async function startRound() {
      const roomId = state.currentRoomId;
      const roomData = state.currentRoomData;
      if (!roomId || !roomData) return;
      if (roomData.hostId !== state.clientId) {
        alert("只有房主可以開始回合");
        return;
      }
      const readyPlayers = Array.from(state.playerMap.values()).filter((p) => p.ready);
      if (!readyPlayers.length) {
        alert("至少要有一位玩家按下準備");
        return;
      }
      const judgeEntry = readyPlayers[0] || state.playerMap.get(state.clientId);
      const judgeId = judgeEntry ? judgeEntry.id : state.clientId;
      const judgeNickname = judgeEntry ? (judgeEntry.nickname || "") : (state.nickname || "");
      await updateDoc(doc(db, "yellowRooms", roomId), {
        phase: "running",
        judgeId,
        judgeNickname,
        currentTopic: roomData.currentTopic || "",
        updatedAt: serverTimestamp()
      });
    }

    async function drawTopic() {
      const roomId = state.currentRoomId;
      const roomData = state.currentRoomData;
      if (!roomId || !roomData) return;
      if (roomData.hostId !== state.clientId) {
        alert("只有房主可以抽題目");
        return;
      }
      try {
        await runTransaction(db, async (tx) => {
          const roomRef = doc(db, "yellowRooms", roomId);
          const roomSnap = await tx.get(roomRef);
          if (!roomSnap.exists()) throw new Error("房間不存在");
          const data = roomSnap.data();
          const deck = Array.isArray(data.topicDeck) ? [...data.topicDeck] : [];
          if (!deck.length) throw new Error("題庫已空，請先重置題目");
          const topic = deck.shift();
          const used = Array.isArray(data.usedTopics) ? [...data.usedTopics, topic] : [topic];
          const judgeId = data.judgeId || state.clientId;
          const judgeNickname = data.judgeNickname || roomData.hostNickname || state.nickname || "";
          tx.update(roomRef, {
            topicDeck: deck,
            usedTopics: used,
            currentTopic: topic,
            phase: "topic",
            judgeId,
            judgeNickname,
            updatedAt: serverTimestamp()
          });
        });
      } catch (error) {
        console.error(error);
        alert(error.message || "抽題目失敗");
      }
    }

    async function recycleTopics() {
      const roomId = state.currentRoomId;
      const roomData = state.currentRoomData;
      if (!roomId || !roomData) return;
      if (roomData.hostId !== state.clientId) {
        alert("只有房主可以操作");
        return;
      }
      const used = Array.isArray(roomData.usedTopics) ? [...roomData.usedTopics] : [];
      const deck = Array.isArray(roomData.topicDeck) ? [...roomData.topicDeck] : [];
      const merged = shuffle([...deck, ...used]);
      await updateDoc(doc(db, "yellowRooms", roomId), {
        topicDeck: merged,
        usedTopics: [],
        currentTopic: "",
        judgeId: null,
        judgeNickname: "",
        phase: "idle",
        updatedAt: serverTimestamp()
      });
    }

    async function resetRoom() {
      const roomId = state.currentRoomId;
      const roomData = state.currentRoomData;
      if (!roomId || !roomData) return;
      if (roomData.hostId !== state.clientId) {
        alert("只有房主可以操作");
        return;
      }
      if (!confirm("確定要重設房間？所有玩家與牌組都會清除。")) return;
      try {
        await runTransaction(db, async (tx) => {
          const roomRef = doc(db, "yellowRooms", roomId);
          const playersRef = collection(roomRef, "players");
          const submissionsRef = collection(roomRef, "submissions");
          const players = await getDocs(playersRef);
          players.forEach((p) => tx.delete(doc(playersRef, p.id)));
          const submissions = await getDocs(submissionsRef);
          submissions.forEach((s) => tx.delete(doc(submissionsRef, s.id)));
          tx.update(roomRef, {
            playerIds: [],
            playerCount: 0,
            hostId: null,
            hostNickname: null,
            currentTopic: "",
            judgeId: null,
            judgeNickname: "",
            phase: "idle",
            usedTopics: [],
            updatedAt: serverTimestamp()
          });
        });
      } catch (error) {
        console.error(error);
        alert(error.message || "重設房間失敗");
      }
    }

    async function submitHand(word) {
      const roomId = state.currentRoomId;
      const player = state.playerMap.get(state.clientId);
      if (!roomId || !player) return;
      if (!player.hand.includes(word)) {
        alert("手牌中沒有該詞語");
        return;
      }
      try {
        await runTransaction(db, async (tx) => {
          const playerRef = doc(db, "yellowRooms", roomId, "players", state.clientId);
          const playerSnap = await tx.get(playerRef);
          if (!playerSnap.exists()) throw new Error("玩家不存在");
          const data = playerSnap.data();
          const newHand = (data.hand || []).filter((v) => v !== word);
          tx.update(playerRef, {
            hand: newHand,
            ready: false,
            lastActive: serverTimestamp()
          });
          const roomRef = doc(db, "yellowRooms", roomId);
          const roomSnap = await tx.get(roomRef);
          const roomData = roomSnap.data();
          const deck = Array.isArray(roomData.wordDeck) ? [...roomData.wordDeck] : [];
          const draw = deck.shift();
          tx.update(roomRef, {
            wordDeck: deck,
            updatedAt: serverTimestamp()
          });
          if (draw) {
            newHand.push(draw);
            tx.update(playerRef, { hand: newHand });
          }
          const submissionRef = doc(collection(roomRef, "submissions"), state.clientId);
          tx.set(submissionRef, {
            playerId: state.clientId,
            nickname: data.nickname,
            word,
            createdAt: serverTimestamp()
          });
        });
      } catch (error) {
        console.error(error);
        alert(error.message || "提交失敗");
      }
    }

    async function giveYellowCard(targetId) {
      const roomId = state.currentRoomId;
      const roomData = state.currentRoomData;
      if (!roomId || !roomData) return;
      if (roomData.hostId !== state.clientId) {
        alert("只有房主可以給黃牌");
        return;
      }
      await runTransaction(db, async (tx) => {
        const playerRef = doc(db, "yellowRooms", roomId, "players", targetId);
        const snap = await tx.get(playerRef);
        if (!snap.exists()) throw new Error("找不到玩家");
        const data = snap.data();
        const total = (data.yellowCards || 0) + 1;
        tx.update(playerRef, { yellowCards: total });
        if (total >= 3) {
          tx.update(doc(db, "yellowRooms", roomId), {
            phase: "finished",
            updatedAt: serverTimestamp()
          });
        }
      });
    }

    async function kickPlayer(targetId) {
      const roomId = state.currentRoomId;
      const roomData = state.currentRoomData;
      if (!roomId || !roomData) return;
      if (roomData.hostId !== state.clientId) {
        alert("只有房主可以踢人");
        return;
      }
      if (targetId === state.clientId) return;
      await runTransaction(db, async (tx) => {
        const roomRef = doc(db, "yellowRooms", roomId);
        const snap = await tx.get(roomRef);
        if (!snap.exists()) return;
        const data = snap.data();
        const playerIds = Array.isArray(data.playerIds) ? [...data.playerIds] : [];
        const index = playerIds.indexOf(targetId);
        if (index === -1) return;
        playerIds.splice(index, 1);
        tx.update(roomRef, {
          playerIds,
          playerCount: playerIds.length,
          updatedAt: serverTimestamp()
        });
        tx.delete(doc(roomRef, "players", targetId));
      });
    }

    function cleanupRoomWatch() {
      if (state.roomDocUnsub) state.roomDocUnsub();
      if (state.playersUnsub) state.playersUnsub();
      if (state.submissionsUnsub) state.submissionsUnsub();
      state.roomDocUnsub = null;
      state.playersUnsub = null;
      state.submissionsUnsub = null;
      state.currentRoomId = null;
      state.currentRoomData = null;
      state.playerMap.clear();
      submissionList.innerHTML = "";
      playersBody.innerHTML = "";
      handSelect.innerHTML = "";
      playerPanel.classList.add("hidden");
      hostPanel.classList.add("hidden");
      playersPanel.classList.add("hidden");
      statusPanel.classList.add("hidden");
    }

    async function watchRoom(roomId, previewOnly) {
      if (!previewOnly && state.currentRoomId === roomId) return;
      if (!previewOnly) cleanupRoomWatch();
      const roomRef = doc(db, "yellowRooms", roomId);
      state.roomDocUnsub = onSnapshot(roomRef, (docSnap) => {
        if (!docSnap.exists()) {
          if (!previewOnly) cleanupRoomWatch();
          return;
        }
        const data = docSnap.data();
        state.currentRoomData = data;
        if (!previewOnly) {
          state.currentRoomId = roomId;
          updateRoomUI(roomId, data);
        }
        renderRoomStatus(data);
      });
      state.playersUnsub = onSnapshot(query(collection(roomRef, "players"), orderBy("joinedAt", "asc")), (snapshot) => {
        const list = snapshot.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }));
        state.playerMap = new Map(list.map((p) => [p.id, p]));
        if (!previewOnly && state.currentRoomId === roomId) {
          renderPlayers(list);
          renderHandOptions(state.playerMap.get(state.clientId));
        }
      });
      state.submissionsUnsub = onSnapshot(collection(roomRef, "submissions"), (snapshot) => {
        if (previewOnly || state.currentRoomId !== roomId) return;
        submissionList.innerHTML = "";
        snapshot.docs.forEach((docSnap) => {
          const data = docSnap.data();
          const item = document.createElement("div");
          item.className = "room-card";
          item.style.background = "rgba(239,236,255,.7)";
          item.innerHTML = `<strong style="font-size:1rem;">匿名投出</strong><span class="subtext">${data.word || "(尚未填寫)"}</span>`;
          if (state.currentRoomData && state.currentRoomData.hostId === state.clientId) {
            const btn = document.createElement("button");
            btn.className = "btn-ghost";
            btn.textContent = "給予黃牌";
            btn.addEventListener("click", () => giveYellowCard(data.playerId));
            item.appendChild(btn);
          }
          submissionList.appendChild(item);
        });
      });
      if (!previewOnly) {
        currentRoomBox.classList.remove("hidden");
      }
    }

    function renderRoomStatus(data) {
      statusPanel.classList.remove("hidden");
      gamePhaseEl.textContent = `遊戲狀態：${data.phase || "等待中"}`;
      judgeInfoEl.textContent = `本局裁判：${data.judgeNickname || "—"}`;
      topicTextEl.textContent = data.currentTopic || "尚未抽題目";
      const remaining = Array.isArray(data.topicDeck) ? data.topicDeck.length : 0;
      topicRemainingEl.textContent = `剩餘題目：${remaining}`;
    }

    function renderPlayers(players) {
      playersPanel.classList.remove("hidden");
      const room = state.currentRoomData;
      const isHost = room && room.hostId === state.clientId;
      hostPanel.classList.toggle("hidden", !isHost);
      btnStart.classList.toggle("hidden", !isHost);
      playerPanel.classList.toggle("hidden", !players.some((p) => p.id === state.clientId));

      playersBody.innerHTML = "";
      players.forEach((player) => {
        const tr = document.createElement("tr");
        if (player.id === state.clientId) tr.classList.add("me");
        if (player.isHost) tr.classList.add("host");
        tr.innerHTML = `
          <td>${player.nickname || "(未命名)"}</td>
          <td>${player.isHost ? "房主" : (player.id === room?.judgeId ? "裁判" : "玩家")}</td>
          <td>${player.yellowCards || 0}</td>
          <td>${player.ready ? "✅" : "⏳"}</td>
          <td>${Array.isArray(player.hand) ? player.hand.length : 0} 張</td>
          <td data-actions></td>
        `;
        const actionsCell = tr.querySelector("[data-actions]");
        if (player.id === state.clientId) {
          const btn = document.createElement("button");
          btn.className = "btn-ghost";
          btn.textContent = player.ready ? "取消準備" : "我準備好了";
          btn.addEventListener("click", toggleReady);
          actionsCell.appendChild(btn);
        } else if (isHost) {
          const kickBtn = document.createElement("button");
          kickBtn.className = "btn-ghost";
          kickBtn.textContent = "踢出";
          kickBtn.addEventListener("click", () => kickPlayer(player.id));
          const cardBtn = document.createElement("button");
          cardBtn.className = "btn-ghost";
          cardBtn.textContent = "黃牌 +1";
          cardBtn.addEventListener("click", () => giveYellowCard(player.id));
          actionsCell.appendChild(kickBtn);
          actionsCell.appendChild(cardBtn);
        }
        playersBody.appendChild(tr);
      });

      const count = players.length;
      const capacity = room?.capacity || 8;
      currentRoomInfo.textContent = `${count} / ${capacity} 人在線`;
      currentRoomName.textContent = `目前房間：${room?.name || room?.id || "—"}`;
    }

    function renderHandOptions(player) {
      handSelect.innerHTML = "";
      if (!player || !Array.isArray(player.hand) || !player.hand.length) {
        const option = document.createElement("option");
        option.value = "";
        option.textContent = player ? "目前沒有手牌" : "尚未加入房間";
        handSelect.appendChild(option);
        handSelect.disabled = true;
        return;
      }
      handSelect.disabled = false;
      player.hand.forEach((word) => {
        const option = document.createElement("option");
        option.value = word;
        option.textContent = word;
        handSelect.appendChild(option);
      });
    }

    function updateRoomUI(roomId, data) {
      if (!roomId || !data) {
        currentRoomBox.classList.add("hidden");
        btnReady.textContent = "我準備好了";
        return;
      }
      currentRoomBox.classList.remove("hidden");
      currentRoomName.textContent = `目前房間：${data.name || roomId}`;
      const count = Array.isArray(data.playerIds) ? data.playerIds.length : (data.playerCount || 0);
      const capacity = data.capacity || 8;
      currentRoomInfo.textContent = `${count} / ${capacity} 人在線`;
      btnReady.textContent = state.playerMap.get(state.clientId)?.ready ? "取消準備" : "我準備好了";
    }

    function shuffle(list) {
      const a = [...list];
      for (let i = a.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }
  </script>
</body>
</html>
